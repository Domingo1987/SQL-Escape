# Nivel 1 – Bienvenida
**Contexto narrativo:**
Despiertas en la sala de control de un barco abandonado. Todo está oscuro y polvoriento. Las luces parpadean mientras un panel digital te muestra un mensaje: “Consulta los registros del personal para abrir la compuerta principal”. Debes resolver una consulta SQL para continuar.

**Fundamentación pedagógica:**
Este primer nivel está diseñado para introducir al jugador en el entorno del juego de manera sencilla pero con una intención significativa y contextualizada. La consulta solicitada —“¿cuántos marineros hay registrados?”— exige el uso de la instrucción **`SELECT COUNT(*)`**, que pertenece al sublenguaje **DQL (Data Query Language)** de SQL. Este sublenguaje se utiliza específicamente para realizar consultas que extraen información de la base de datos sin alterarla, lo cual resulta ideal en una etapa inicial de exploración y reconocimiento.
Se opta por **`COUNT(*)`** porque permite al jugador obtener una visión cuantitativa del contenido de una tabla, sin necesidad de conocer su estructura interna ni campos específicos. Esta acción simula un proceso lógico y realista: si un jugador despierta en un entorno desconocido y deshabitado, lo primero que intentaría saber es cuántas personas estuvieron allí antes. Traducido al mundo de las bases de datos, eso equivale a contar los registros existentes.
Desde un punto de vista pedagógico, esta instrucción sirve como primer contacto concreto con SQL, centrado en la familiarización con la sintaxis básica de **`SELECT`**. Al mismo tiempo, introduce un concepto fundamental: los registros como unidad mínima de análisis de una tabla. El uso de **`COUNT(*)`** evita que el jugador deba preocuparse por los nombres de columnas o condiciones complejas, facilitando un primer paso accesible y enfocado en la lógica de consulta.
Además, esta instrucción tiene aplicaciones frecuentes en contextos reales: conteo de usuarios en un sistema, número de ventas registradas, cantidad de productos en stock, entre otros. Por lo tanto, además de cumplir un propósito narrativo dentro del juego, introduce un recurso técnico con amplio valor práctico. En síntesis, este nivel funciona como una puerta de entrada tanto al universo narrativo como al lenguaje SQL, estimulando la curiosidad a través de una consulta elemental pero significativa.

# Nivel 2 – El Libro de Guardia 
**Contexto narrativo:** 
Explorando el barco envuelto en niebla, el jugador encuentra el "Libro de Guardia", un antiguo registro de la tripulación. Una nota invita a mirar hacia adentro, a reconocer a quienes están o estuvieron a bordo. Este elemento refuerza el vínculo entre la narrativa y el objetivo del juego: explorar, descubrir y aprender.

**Fundamentación pedagógica:** En este nivel, se propone al jugador una serie de consultas orientadas a mostrar únicamente los nombres de los marineros registrados en el “Libro de Guardia”. Para ello, se utiliza la instrucción **`SELECT nombre FROM MARINERO`**, junto con variantes como **`DISTINCT`**, alias de tabla y **`ORDER BY`**. Todas estas instrucciones forman parte del sublenguaje **DQL (Data Query Language)** de SQL, que se utiliza exclusivamente para consultar, seleccionar y organizar datos existentes sin modificarlos.
La elección de estas instrucciones responde tanto a la lógica narrativa como a una secuencia pedagógica progresiva. En la historia, el jugador encuentra un registro específico y desea saber quiénes figuran en él. Mostrar únicamente los nombres, y no todas las columnas de la tabla, introduce el concepto fundamental de selección específica de campos, reforzando que las bases de datos permiten obtener solo la información relevante según el propósito. Esto prepara al jugador para evitar el uso innecesario de **`SELECT *`** y empezar a tomar decisiones conscientes sobre qué datos necesita.
El uso de **`DISTINCT`** tiene una justificación narrativa clara: se busca reconocer identidades individuales y no repetir nombres, algo muy común si, por ejemplo, ciertos marineros aparecen varias veces por distintos turnos o funciones. Esta instrucción enseña cómo eliminar duplicados en los resultados y al mismo tiempo comunica una noción de limpieza y precisión en la consulta.
**`ORDER BY`** cumple una doble función. Narrativamente, ayuda a organizar los datos como si uno estuviera hojeando un libro real donde los nombres están ordenados para facilitar su lectura. Didácticamente, introduce al jugador en la idea de que los datos consultados no siempre se presentan en el orden original de la tabla, y que se puede controlar su disposición para facilitar búsquedas o visualización.
Finalmente, se introduce el uso de alias de tabla, como en **`FROM MARINERO M`**, lo que si bien no es obligatorio en este caso simple, constituye una buena práctica desde el inicio. Enseñar esta técnica tempranamente es clave porque cuando se avance hacia consultas más complejas (con múltiples tablas, relaciones o subconsultas), el uso de alias será indispensable para la claridad y brevedad del código SQL.
En conjunto, este nivel no solo continúa con la inmersión narrativa del juego, sino que fortalece la alfabetización en SQL, ayudando al jugador a comprender cómo filtrar, depurar y organizar información dentro de una base de datos de forma lógica, precisa y orientada al objetivo.

# Nivel 3 – Las Bitácoras del Silencio 
**Contexto narrativo:**
Al acceder a la sala de mando, las pantallas comienzan a cobrar vida. La información almacenada en la memoria del barco revela fragmentos de las travesías pasadas: fechas, condiciones del mar, y pistas del recorrido del capitán. El mensaje cifrado sugiere que todo lo que ocurrió dejó huella, y esas huellas están esperando ser leídas.

**Fundamentación pedagógica:**
En este nivel, el jugador se enfrenta por primera vez a la necesidad de leer datos combinados, lo que implica seleccionar múltiples columnas en una misma consulta mediante **`SELECT`** **`fecha`**, estado **`FROM NAVEGACIÓN`**. Esta instrucción sigue perteneciendo al sublenguaje **DQL (Data Query Language)**, enfocado en la exploración y análisis de datos existentes sin alterarlos. El objetivo pedagógico aquí es expandir la comprensión del jugador sobre cómo las bases de datos almacenan diferentes tipos de información que pueden relacionarse entre sí para construir sentido.
Narrativamente, el jugador accede a las bitácoras del barco: registros cronológicos que contienen eventos clave, como las condiciones del mar durante cada travesía. Por ello, tiene pleno sentido que la consulta extraiga más de una columna por registro, combinando información numérica o temporal **`(fecha)`** con descripciones cualitativas **`(estado)`**. Esta estructura permite leer patrones y establecer relaciones entre columnas, sin necesidad de aplicar aún condiciones de filtrado **`(WHERE)`**. Se trata de un paso intermedio crucial en el dominio de SQL, donde se comienza a pensar en filas como unidades de observación compuestas por múltiples variables.
El uso de **`ORDER BY`**, si bien opcional, se convierte en una herramienta poderosa en este punto del juego. Desde el enfoque narrativo, permite reconstruir la secuencia de los eventos, como si el jugador estuviera literalmente leyendo un diario de navegación. Desde lo pedagógico, introduce el valor de ordenar los resultados para facilitar su interpretación, en este caso, cronológicamente, algo esencial en tareas que implican análisis histórico o seguimiento de eventos.
También se mantiene la práctica del uso de alias de tabla, como por ejemplo **`FROM NAVEGACIÓN N`**, lo cual puede parecer redundante en consultas simples, pero es fundamental como preparación para estructuras más complejas con múltiples tablas y uniones. Consolidar esta práctica desde los primeros niveles garantiza que el jugador la adopte como parte del estilo de escritura SQL limpio y mantenible.
En síntesis, este nivel funciona como una transición entre el simple conteo o listado y el análisis de relaciones entre datos. Al invitar al jugador a explorar las “huellas del pasado”, se logra integrar narración y estructura de datos, favoreciendo el desarrollo de competencias de lectura relacional dentro del entorno SQL. Además, establece las bases para los próximos niveles, donde probablemente se requerirá comparar, filtrar o cruzar columnas en función de criterios específicos.

# Nivel 4 – Ecos en los Sensores 
**Contexto narrativo:**
En la penumbra de la sala de máquinas, sensores envejecidos siguen funcionando. Un archivo antiguo alerta sobre la importancia de cuidar más a los que han trabajado más. El jugador debe analizar estos datos para tomar decisiones de mantenimiento urgentes, priorizando según la antigüedad de servicio.

**Fundamentación pedagógica:**
Este nivel introduce un conjunto de instrucciones que permiten realizar consultas más precisas y estratégicas: **`ORDER BY`** con **`DESC`**, la cláusula **`WHERE`** y el modificador **`LIMIT`**. Todas ellas pertenecen al sublenguaje **DQL (Data Query Language)**, cuyo propósito es consultar, filtrar, organizar y restringir la visualización de datos sin modificarlos. El aprendizaje aquí se centra en cómo seleccionar información relevante dentro de un conjunto más amplio, usando criterios lógicos y operativos.
Narrativamente, el jugador se enfrenta al desafío de priorizar el mantenimiento de sensores antiguos. La base de esta decisión radica en la antigüedad de servicio, representada por una columna como anios_servicio. Por tanto, la instrucción **`ORDER BY anios_servicio DESC`** permite ordenar los sensores de mayor a menor antigüedad, lo que traduce directamente una necesidad contextual (dar prioridad a los más antiguos) en una acción concreta dentro de SQL. Esto refuerza la capacidad del jugador de utilizar los datos como herramienta de diagnóstico.
La cláusula **`WHERE anios_servicio > 0`** introduce por primera vez un filtro condicional, elemento central del lenguaje SQL. Aquí se utiliza para excluir sensores inactivos o irrelevantes, reforzando la noción de que no siempre interesa trabajar con la totalidad de una tabla, sino solo con el subconjunto de datos que cumplen determinados criterios. A nivel pedagógico, esta es una instancia clave para comprender la lógica de extracción selectiva y su papel en la toma de decisiones basada en datos.
El uso de **`LIMIT`**, por su parte, incorpora un componente estratégico y realista. Mostrar únicamente los “top 3” sensores más antiguos simula una situación de recursos limitados, donde no es posible atender todos los casos y es necesario priorizar. Este tipo de consulta enseña al jugador cómo controlar la cantidad de resultados devueltos por una búsqueda, una práctica común en el análisis de grandes volúmenes de datos o en interfaces que muestran solo lo más relevante (como rankings, alertas o dashboards).
Además, se continúa promoviendo el uso de alias de tabla para mantener la claridad del código, especialmente útil si luego se incorporan combinaciones de múltiples fuentes de datos.
En conjunto, este nivel permite al jugador consolidar varias habilidades fundamentales: aplicar filtros, ordenar datos según criterios significativos, y limitar los resultados para una toma de decisiones más enfocada. Es un momento ideal para pasar de la exploración pasiva a la acción analítica, acercando al jugador a escenarios de uso real en mantenimiento preventivo, monitoreo técnico o análisis de desempeño.

# Nivel 5 – El Diario del Combustible 
**Contexto narrativo:**
Entre tanques corroídos y papeles dispersos, el jugador descubre el "Diario del Combustible", un registro de cuánto se ha consumido en cada jornada. La inscripción tallada en la compuerta sugiere una verdad obvia pero poderosa: recorrer más tiene un costo, y el combustible es la huella que deja el viaje.

**Fundamentación pedagógica:**
Este nivel profundiza en el uso del sublenguaje **DQL (Data Query Language)**, integrando nuevamente instrucciones como **`SELECT`**, **`WHERE`**, **`ORDER BY DESC`** y alias de tabla. A través de la consulta **`SELECT fecha`**, **`cantidad_utilizada FROM CONSUMO WHERE cantidad_utilizada > 100 ORDER BY cantidad_utilizada DESC`**, se busca que el jugador identifique y analice los registros con mayor consumo de combustible, conectando directamente con el contexto narrativo y con habilidades analíticas más avanzadas.
Narrativamente, el jugador accede al "Diario del Combustible", una bitácora técnica que permite reconstruir cómo se ha utilizado la energía del barco a lo largo de sus recorridos. Este enfoque apunta a desarrollar la capacidad de detectar patrones de consumo, identificar posibles excesos y empezar a tomar decisiones basadas en datos históricos. Es un paso importante porque introduce la noción de que los datos no solo se observan, sino que se interpretan con un propósito.
La cláusula **`WHERE cantidad_utilizada > 100`** permite filtrar los registros relevantes, en este caso, aquellos donde el consumo supera un umbral considerado alto. Esto enseña al jugador que las bases de datos permiten enfocar el análisis en aspectos críticos o anómalos, lo cual es una habilidad clave en tareas como monitoreo de recursos, control de gastos o evaluación de eficiencia.
Por su parte, **`ORDER BY cantidad_utilizada DESC`** organiza los resultados desde el consumo más alto al más bajo, lo que facilita la identificación rápida de los registros más significativos. Esta instrucción refuerza el aprendizaje sobre cómo estructurar la salida de una consulta para facilitar la interpretación y la toma de decisiones, especialmente cuando se trabaja con series numéricas que representan magnitudes acumulativas o costos.
El uso continuado de alias **`(FROM CONSUMO C, por ejemplo)`** refuerza las buenas prácticas ya introducidas en niveles anteriores, preparando al jugador para trabajar con estructuras más extensas y consultas más complejas donde la legibilidad del código es esencial.
Este nivel marca una transición hacia el análisis con propósito: ya no se trata solo de listar o explorar, sino de filtrar, ordenar e interpretar datos cuantitativos que tienen implicaciones prácticas en la narrativa del juego y, por analogía, en el mundo real. El jugador comienza a actuar como un verdadero analista de datos, desarrollando la habilidad de enfocar su atención en lo relevante y detectar comportamientos por medio del lenguaje SQL.

# Nivel 6 – El Código del Ingeniero 
**Contexto narrativo:**
En la sala de planos, rodeado de diseños técnicos firmados por distintos marineros, un mensaje advierte que cada creador deja su marca. El jugador debe encontrar a aquellos marineros que se identifican como “Ingeniero” en su descripción, descubriendo quiénes dejaron su huella en la construcción y mantenimiento del barco.

**Fundamentación pedagógica:**
Este nivel introduce al jugador en el uso del operador **`LIKE`** con comodines **`(%Ingeniero%)`**, una herramienta fundamental del sublenguaje **DQL (Data Query Language**) que permite realizar búsquedas textuales dentro de campos de tipo cadena. También se incorpora la función **`LOWER()`** como técnica de normalización de texto, junto con ORDER BY y el uso de alias de tabla, consolidando así varias buenas prácticas en una única consulta.
Narrativamente, el jugador se convierte en un investigador que debe identificar a los marineros que cumplieron un rol técnico específico: el de ingeniero. Esta tarea ya no se basa en datos numéricos ni completamente estructurados, sino en descripciones textuales más libres y diversas. En este contexto, el uso del operador **`LIKE`** permite buscar coincidencias parciales dentro de los textos, detectando patrones lingüísticos sin necesidad de coincidencias exactas. Es un momento clave donde el juego plantea una búsqueda más flexible e interpretativa, muy cercana al modo en que los humanos buscamos en documentos o sistemas.
El uso del comodín **`%`** antes y después del término buscado **`(%Ingeniero%)`** habilita la localización de esta palabra en cualquier posición dentro del campo de texto, lo cual es especialmente útil si el contenido varía de un registro a otro (por ejemplo: “Jefe de Ingeniería”, “Asistente Ingeniero Naval”, “Técnico / Ingeniero”). Este tipo de búsqueda sería ineficaz usando comparaciones directas con =. En entornos reales, se utiliza en formularios de búsqueda, exploración de perfiles laborales, procesamiento de textos y más.
La función **`LOWER()`** se introduce como método de normalización textual, asegurando que la búsqueda no se vea afectada por diferencias de mayúsculas y minúsculas. Su inclusión refuerza la idea de que al trabajar con textos es necesario “estandarizar” la información para mejorar la precisión de los resultados, práctica común en análisis de datos desestructurados.
**`ORDER BY`**, aplicado aquí, sirve para organizar alfabéticamente los resultados por nombre u otro campo pertinente, haciendo que los datos extraídos sean más legibles y útiles para el jugador-investigador. Y el uso continuo de alias sigue promoviendo escritura clara y estructurada, especialmente útil cuando las consultas comienzan a incorporar funciones y condiciones adicionales.
Desde lo pedagógico, este nivel marca un punto de inflexión: el jugador comienza a trabajar con información imprecisa, dispersa o no estandarizada, tal como ocurre frecuentemente en bases de datos reales. Se fomenta la habilidad de formular consultas que imitan la lógica humana de exploración, combinando intuición narrativa con precisión sintáctica.
Este tipo de instrucción resulta especialmente útil en campos como minería de texto, recuperación de información, gestión de RRHH o análisis de formularios abiertos, consolidando una competencia transversal: buscar significados dentro del lenguaje humano a través del lenguaje SQL.

# Nivel 7 – El Archivo Genético del Barco 
**Contexto narrativo:**
En la enfermería del barco, un escáner revela datos vitales sobre la tripulación. El archivo “Estado Físico de la Tripulación” muestra que el cuerpo también tiene su travesía y revela información importante sobre la edad de los marineros. Para garantizar el bienestar, es clave identificar a quienes tienen más experiencia y necesitan mayor cuidado.

**Fundamentación pedagógica:**
Este nivel continúa fortaleciendo el dominio del sublenguaje **DQL (Data Query Language)**, integrando la instrucción **`SELECT`** con selección de múltiples columnas (**`nombre`**,**`edad`**), cláusulas de filtrado condicional **`(WHERE edad > 40)`**, ordenamiento **`(ORDER BY edad DESC)`** y el uso consistente de alias de tabla. En este momento del juego, se espera que el jugador no solo recupere información, sino que aplique criterios numéricos precisos para tomar decisiones informadas, lo cual simula tareas reales de gestión o evaluación de personas.
Narrativamente, el jugador accede al archivo “Estado Físico de la Tripulación” dentro de la enfermería del barco, lo que implica un enfoque más humano y responsable. La consigna es detectar a los marineros con más edad, interpretando que la experiencia también puede estar asociada a mayor desgaste físico y por tanto necesidad de cuidado especial. Esto justifica plenamente el uso de la condición **`WHERE edad > 40`**, enfocando el análisis en un subconjunto de registros críticos, en lugar de consultar toda la base de datos.
**`ORDER BY edad DESC`** refuerza el valor del análisis, al permitir al jugador priorizar a quienes tienen mayor edad primero, es decir, a aquellos que requieren más atención de manera urgente. Esta forma de ordenar los datos ayuda a visualizar la jerarquía de necesidades, fortaleciendo la toma de decisiones a partir de datos estructurados y jerarquizados.
Además, este nivel es ideal para introducir la noción de validación de datos incompletos o nulos, preparando al jugador para entornos de datos reales, donde puede haber registros sin edad declarada o con valores inconsistentes. Aunque no se implemente directamente aún, se puede comenzar a mencionar la importancia de verificar la calidad de los datos antes de realizar análisis, abriendo camino al uso futuro de condiciones como **`IS NOT NULL`**.
Desde una perspectiva pedagógica, este nivel permite consolidar el uso de condiciones numéricas como criterio de selección, reforzando que no solo se consulta información, sino que se filtra estratégicamente en función de necesidades concretas. También se estimula la comprensión de que los datos no se interpretan todos por igual, y que el contexto define qué subset es más relevante. Así, el jugador desarrolla competencias de análisis crítico, aplicables en escenarios como evaluación de personal, segmentación por edades, estudios de salud o estrategias de intervención focalizada.
Finalmente, el uso consistente de alias contribuye a mantener un código claro y ordenado, lo cual se vuelve esencial a medida que las consultas ganan complejidad.

# Nivel 8 – Coordenadas de la Verdad 
**Contexto narrativo:**
Un mapa digital revela las islas que el barco ha visitado, cada una con su propia historia y población. El mensaje recuerda que conocer los detalles de cada lugar es esencial para comprender su esencia y planificar nuevas rutas.

**Fundamentación pedagógica:**
En este nivel, el jugador profundiza su dominio del sublenguaje **DQL (Data Query Language)** utilizando instrucciones como **`SELECT`** para extraer múltiples columnas (**`nombre`**, **`habitantes`**), **`WHERE puerto = TRUE`** para aplicar condiciones lógicas sobre datos booleanos, y **`ORDER BY`** habitantes **`DESC`** para priorizar los resultados en función de su población. Esta combinación permite al jugador realizar un análisis geográfico y demográfico estructurado, apoyado en datos que simulan un contexto real de planificación y toma de decisiones.
Narrativamente, el jugador accede a un mapa digital que revela las islas visitadas por el barco, cada una con características distintas. La misión es identificar qué islas tienen puerto habilitado, lo cual representa puntos clave de conexión, comercio o refugio. Esta necesidad se traduce naturalmente en la condición **`WHERE puerto = TRUE`**, que introduce al jugador en el manejo de atributos booleanos, es decir, campos que solo pueden tener los valores TRUE o FALSE. Esta es una habilidad esencial en cualquier análisis lógico de bases de datos.
La consulta se completa con el ordenamiento por cantidad de habitantes **`(ORDER BY habitantes DESC)`**, lo cual permite establecer una jerarquía de importancia entre las islas portuarias, priorizando aquellas que podrían tener mayor infraestructura, recursos o desafíos logísticos. Este paso no solo mejora la comprensión de cómo ordenar resultados, sino que estimula el razonamiento estratégico: en un entorno limitado, no todas las islas podrán ser visitadas, por lo que se vuelve clave saber a cuáles conviene ir primero.
Desde lo pedagógico, este nivel permite consolidar varios aprendizajes previos: el uso de múltiples columnas, el filtrado por condiciones específicas y el ordenamiento por criterios cuantitativos. Pero además, introduce un nuevo tipo de dato: el booleano, que es común en bases de datos de todo tipo (campos como “activo/inactivo”, “disponible/no disponible”, “verificado/no verificado”). Reconocer cómo consultar sobre estos valores es fundamental para construir filtros binarios que segmenten información relevante.
Este escenario también puede preparar al jugador para desafíos más complejos donde los booleanos se combinen con otras condiciones (**`AND`**, **`OR`**), o donde se tomen decisiones basadas en múltiples factores.
En conjunto, este nivel ofrece una experiencia de análisis más estratégica y aplicada, permitiendo al jugador actuar como un planificador de rutas basado en evidencia. Esto consolida una visión más amplia de lo que puede lograrse con SQL: no solo explorar, sino comparar, priorizar y decidir con base en datos concretos.

# Nivel 9 – Tiempo en el Mar 
**Contexto narrativo:**
Una antigua bitácora detalla los movimientos del barco entre islas, registrando fechas de entrada y salida. El mensaje subraya que no solo importa el destino, sino también la duración de cada travesía, haciendo énfasis en el tiempo como un factor clave para entender el viaje.

**Fundamentación pedagógica:**
En este nivel, el jugador utiliza instrucciones del sublenguaje **DQL** como **`SELECT`** de múltiples columnas, **`WHERE`** para aplicar filtros específicos (por ejemplo, movimientos de salida) y **`ORDER BY`** en múltiples criterios (como **`número de barco`** y **`fecha`**). Este conjunto de herramientas permite realizar un análisis secuencial y estructurado de eventos registrados en la base de datos, simulando tareas reales de reconstrucción histórica o análisis de rutas logísticas.
Narrativamente, el jugador accede a una bitácora que no solo detalla los destinos visitados, sino también los tiempos y secuencias de las travesías. Esto introduce una nueva dimensión de análisis: el tiempo como variable crítica para entender el comportamiento y las decisiones del pasado. Ya no se trata únicamente de saber qué ocurrió, sino cuándo y en qué orden, una perspectiva esencial para comprender causas, consecuencias y patrones de movimiento.
La cláusula **`WHERE tipo_movimiento = 'salida'`** permite enfocar el análisis en los registros que marcan el inicio de cada trayecto, filtrando datos irrelevantes para el objetivo actual. Este tipo de filtrado específico refuerza la idea de que cada consulta debe estar alineada con una pregunta clara o un problema concreto, habilidad central en la práctica del análisis de datos.
El uso de múltiples columnas en **`ORDER BY`** (por ejemplo, **`ORDER BY numero_barco, fecha`**) permite ordenar los registros de manera jerárquica: primero por embarcación y luego por fecha, logrando una estructura cronológica dentro de cada unidad de análisis. Este tipo de ordenamiento múltiple es fundamental cuando se desea comparar comportamientos repetidos en distintas categorías, como rutas realizadas por diferentes barcos o equipos de trabajo.
Desde lo pedagógico, este nivel entrena la lectura y organización cronológica de eventos, fortaleciendo la capacidad del jugador para identificar secuencias, intervalos y frecuencias. Este tipo de análisis es clave en contextos como auditorías, planificación de recursos, seguimiento de procesos, o evaluación de operaciones logísticas. Además, es un paso previo para calcular duraciones, detectar anomalías en los tiempos o correlacionar eventos a través del tiempo.
Este nivel también consolida habilidades anteriores (selección, filtrado, ordenamiento) y anticipa estructuras más avanzadas, como el uso de funciones de fecha, cálculos de intervalos o subconsultas temporales. Además, se mantiene el uso de alias como parte de las buenas prácticas de claridad y mantenimiento del código.
En conjunto, este nivel representa una transición hacia el análisis temporal complejo, permitiendo al jugador comenzar a pensar en el viaje como un proceso con duración, ritmo y evolución, y no solo como una serie de puntos aislados.

# Nivel 10 – Diagnóstico del Sistema Central 
**Contexto narrativo:**
Frente al núcleo de control del barco, un monitor alerta sobre sensores y su estado. El mensaje indica que el tipo de sensor está relacionado con la probabilidad de falla, por lo que es crucial conocer cuántos sensores de cada tipo hay para anticipar problemas.

**Fundamentación pedagógica:**
Este nivel introduce formalmente el uso de **`GROUP BY`** junto con funciones agregadas como **`COUNT(*)`**, combinadas con alias y **`ORDER BY`**, todos elementos clave del sublenguaje **DQL (Data Query Language)**. Estas instrucciones permiten al jugador pasar del análisis individual al análisis grupal, resumiendo grandes volúmenes de información en datos significativos por categoría. Es un avance importante en la progresión pedagógica del juego, ya que representa un punto de inflexión: del detalle al diagnóstico general.
Narrativamente, el jugador se encuentra frente al núcleo del sistema central del barco, que emite una alerta sobre el posible mal funcionamiento de sensores. Ya no basta con mirar cada sensor por separado: ahora es necesario detectar patrones de riesgo agrupando los datos por tipo de sensor, para identificar qué grupos podrían estar más comprometidos. Este cambio de perspectiva –de lo particular a lo global– se refleja directamente en el uso de GROUP BY tipo_sensor, que permite agrupar todos los registros que comparten una misma categoría.
La función **`COUNT(*)`** aplicada sobre cada grupo cuenta la cantidad de sensores de ese tipo, generando así un informe cuantitativo por categoría, útil para estimar exposición al riesgo, necesidades de mantenimiento o distribución de recursos. El ordenamiento con **`ORDER BY COUNT(*) DESC`**(opcional pero relevante) puede usarse para priorizar los tipos más frecuentes o problemáticos, ayudando al jugador a enfocar su atención en los casos más críticos.
Desde el punto de vista pedagógico, este nivel permite introducir una nueva lógica de consulta: la agregación, que es central en análisis de bases de datos. A través de ella, se entrena al jugador en técnicas de síntesis de información, una competencia indispensable cuando se trabaja con conjuntos grandes de datos que deben ser interpretados desde una perspectiva estratégica. Este tipo de estructura es común en reportes de rendimiento, diagnósticos operativos, análisis de inventarios, entre otros.
Además, se refuerzan buenas prácticas como el uso de alias para simplificar la sintaxis, especialmente cuando se combinan múltiples componentes en la consulta. La combinación de **`GROUP BY, COUNT(*)`** y **`ORDER BY`** da lugar a consultas más robustas y versátiles, capaces de responder a preguntas del tipo “¿cuántos de cada hay?”, que son fundamentales en escenarios reales de planificación, monitoreo o supervisión.
En síntesis, este nivel consolida el trayecto del jugador hacia una comprensión profunda del análisis SQL, al introducir el concepto de agregación por categorías, y al permitirle actuar como un diagnosticador de sistemas complejos. Es una culminación lógica y potente del recorrido iniciado en niveles anteriores, donde el foco estaba puesto en el dato individual. Ahora, la mirada se amplía para abarcar el conjunto, cerrando el ciclo de aprendizaje con una visión estratégica y global.


